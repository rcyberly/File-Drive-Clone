// controllers/fileController.js

// FIX: Update import path to reflect new sibling relationship (if db.js was in a separate config folder at root)
import pool from '../config/db.js'; 
import * as fs from 'fs/promises'; // Use fs/promises for asynchronous file operations
import path from 'path';
import { fileURLToPath } from 'url';

// --- Path Setup ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename); // /path/to/project-root/controllers
// STORAGE_DIR now points to the 'storage' folder, which is a sibling of 'controllers' 
// in the project root directory.
const STORAGE_DIR = path.join(__dirname, '..', 'storage'); // Resolves to /path/to/project-root/storage


// --- Helper Functions ---

/**
 * Ensures the parent_id is valid for the user and is indeed a folder.
 * @param {string} parentId The potential parent folder ID (or null for root).
 * @param {string} userId The current user's ID.
 * @returns {object|null} The parent folder object or null if valid (root).
 */
const getValidParent = async (parentId, userId) => {
    if (!parentId || parentId.toLowerCase() === 'root') {
        return null; // Root level is valid
    }

    const result = await pool.query(
        `SELECT id, is_folder 
         FROM files 
         WHERE id = $1 AND user_id = $2`, 
        [parentId, userId]
    );

    const parent = result.rows[0];

    if (!parent || !parent.is_folder) {
        throw new Error('Parent ID is invalid or does not refer to a folder.');
    }

    return parent;
};


// --- Controller Functions (MATCHING router/file.js) ---

/**
 * GET /api/files?parent_id=[id]
 * Lists all files and folders for the current user in a specific directory.
 */
export const listFiles = async (req, res) => {
    try {
        const userId = req.user.id; // Assuming auth middleware sets req.user.id
        // Get parent_id from query string, default to null (root) if not provided
        const parentId = req.query.parent_id || null; 

        let query, params;

        if (parentId && parentId.toLowerCase() !== 'root') {
            // Find items within a specific folder
            query = `
                SELECT id, name, is_folder, size_bytes, mime_type, created_at
                FROM files
                WHERE user_id = $1 AND parent_id = $2
                ORDER BY is_folder DESC, name ASC`;
            params = [userId, parentId];
        } else {
            // Find items at the root level (parent_id IS NULL)
            query = `
                SELECT id, name, is_folder, size_bytes, mime_type, created_at
                FROM files
                WHERE user_id = $1 AND parent_id IS NULL
                ORDER BY is_folder DESC, name ASC`;
            params = [userId];
        }

        const result = await pool.query(query, params);
        res.status(200).json(result.rows);
    } catch (error) {
        console.error('Error listing files:', error);
        res.status(500).json({ message: 'Internal Server Error while listing contents.' });
    }
};


/**
 * POST /api/files
 * Creates a file (upload) or a folder (metadata creation).
 */
export const createItem = async (req, res) => {
    const client = await pool.connect();
    try {
        await client.query('BEGIN'); // Start transaction

        const userId = req.user.id; 
        const { name, is_folder, parent_id } = req.body; // name and is_folder come from the request body

        // 1. Validate Parent Folder
        // This implicitly checks if the user owns the parent folder.
        await getValidParent(parent_id, userId);

        let query, params, responseData;

        // --- A. Handle Folder Creation ---
        if (is_folder === 'true' || is_folder === true) {
            if (!name || typeof name !== 'string') {
                throw new Error('Folder name is required.');
            }

            query = `
                INSERT INTO files (user_id, name, parent_id, is_folder)
                VALUES ($1, $2, $3, TRUE)
                RETURNING id, name, created_at`;
            params = [userId, name, parent_id];
            
            const result = await client.query(query, params);
            responseData = { message: 'Folder created successfully.', item: result.rows[0] };

        // --- B. Handle File Upload ---
        } else if (req.file) {
            const { originalname, filename, size, mimetype } = req.file;
            
            query = `
                INSERT INTO files (user_id, name, parent_id, is_folder, storage_key, size_bytes, mime_type)
                VALUES ($1, $2, $3, FALSE, $4, $5, $6)
                RETURNING id, name, size_bytes, mime_type, created_at`;
            
            // filename generated by uploadMiddleware is the unique storage_key
            params = [userId, originalname, parent_id, filename, size, mimetype];
            
            const result = await client.query(query, params);
            responseData = { message: 'File uploaded successfully.', item: result.rows[0] };

        } else {
            throw new Error('Invalid request: Must provide a file or set is_folder=true.');
        }

        await client.query('COMMIT'); // Commit transaction
        res.status(201).json(responseData);

    } catch (error) {
        await client.query('ROLLBACK'); // Rollback on failure
        console.error('Error creating item:', error);
        
        // Custom check for PostgreSQL duplicate key error (23505 is the error code for UNIQUE constraint)
        if (error.code === '23505') {
             res.status(409).json({ message: `An item named '${req.body.name}' already exists in this folder.` });
             return;
        }

        // Clean up the physical file if DB insertion failed for a file upload
        if (req.file) {
            try {
                await fs.unlink(req.file.path);
                console.log(`Cleaned up orphaned file: ${req.file.path}`);
            } catch (fsError) {
                console.error('Error cleaning up orphaned file:', fsError);
            }
        }
        
        res.status(500).json({ message: error.message || 'Internal Server Error during item creation.' });
    } finally {
        client.release();
    }
};


/**
 * PUT /api/files/:id
 * Renames or moves a file/folder.
 */
export const updateItem = async (req, res) => {
    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        const userId = req.user.id;
        const itemId = req.params.id;
        const { name, parent_id } = req.body;

        // 1. Check item ownership and existence
        const currentItemResult = await client.query(
            `SELECT id, name, parent_id, is_folder 
             FROM files 
             WHERE id = $1 AND user_id = $2 FOR UPDATE`, 
            [itemId, userId]
        );
        const currentItem = currentItemResult.rows[0];

        if (!currentItem) {
            await client.query('ROLLBACK');
            return res.status(404).json({ message: 'Item not found or access denied.' });
        }

        // 2. Validate new parent folder (if provided)
        let newParentId = parent_id !== undefined ? parent_id : currentItem.parent_id;

        if (newParentId === itemId) {
             throw new Error('An item cannot be its own parent.');
        }

        if (newParentId) {
            // Validate the target parent folder
            await getValidParent(newParentId, userId);
        }

        // 3. Construct update query
        let updates = [];
        let params = [];
        let paramIndex = 1;

        if (name && name !== currentItem.name) {
            updates.push(`name = $${paramIndex++}`);
            params.push(name);
        }

        // Set the parent_id only if it's explicitly provided or if it was null and needs to be set to a folder ID
        if (parent_id !== undefined && newParentId !== currentItem.parent_id) {
            // Note: newParentId could be null (root)
            updates.push(`parent_id = $${paramIndex++}`);
            params.push(newParentId); 
        }

        if (updates.length === 0) {
            await client.query('ROLLBACK');
            return res.status(200).json({ message: 'No changes provided.' });
        }

        params.push(itemId); // Item ID for WHERE clause

        const updateQuery = `
            UPDATE files 
            SET ${updates.join(', ')} 
            WHERE id = $${paramIndex} 
            RETURNING id, name, parent_id, updated_at`;

        const result = await client.query(updateQuery, params);

        await client.query('COMMIT');
        res.status(200).json({ message: 'Item updated successfully.', item: result.rows[0] });

    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Error updating item:', error);
        
        if (error.code === '23505') {
            res.status(409).json({ message: `An item named '${req.body.name}' already exists in the target folder.` });
            return;
        }
        
        res.status(500).json({ message: error.message || 'Internal Server Error during update.' });
    } finally {
        client.release();
    }
};


/**
 * DELETE /api/files/:id
 * Deletes a file or folder (recursively deletes contents).
 */
export const deleteItem = async (req, res) => {
    const client = await pool.connect();
    try {
        await client.query('BEGIN');

        const userId = req.user.id;
        const itemId = req.params.id;

        // 1. Get the item and its descendants
        // Recursive query to find all children (and the item itself)
        const descendantsResult = await client.query(
            `WITH RECURSIVE item_tree AS (
                SELECT id, storage_key, is_folder 
                FROM files 
                WHERE id = $1 AND user_id = $2
              UNION ALL
                SELECT f.id, f.storage_key, f.is_folder
                FROM files f
                INNER JOIN item_tree t ON t.id = f.parent_id
            )
            SELECT id, storage_key 
            FROM item_tree`, 
            [itemId, userId]
        );
        
        const itemsToDelete = descendantsResult.rows;

        if (itemsToDelete.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ message: 'Item not found or access denied.' });
        }

        // 2. Delete physical files from disk
        const fileDeletionPromises = itemsToDelete
            .filter(item => item.storage_key) // Only files (non-folders) have a storage_key
            .map(item => {
                const filePath = path.join(STORAGE_DIR, item.storage_key);
                return fs.unlink(filePath).catch(err => {
                    // Log but ignore file-not-found error (ENOENT), 
                    // as database record is the source of truth for deletion
                    if (err.code !== 'ENOENT') throw err;
                    console.warn(`File ${item.storage_key} not found on disk, continuing deletion.`);
                });
            });

        await Promise.all(fileDeletionPromises);

        // 3. Delete records from database (The CASCADE ON DELETE constraint in the schema 
        // handles children deletion if we delete the parent, but since we already selected all
        // descendants, we delete them all by ID.
        // Since the recursive query finds all descendants, we delete them all by ID.
        const idsToDelete = itemsToDelete.map(item => item.id);
        await client.query(`DELETE FROM files WHERE id = ANY($1::uuid[])`, [idsToDelete]);
        
        await client.query('COMMIT');
        res.status(200).json({ message: 'Item and all contents deleted successfully.' });

    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Error deleting item:', error);
        res.status(500).json({ message: 'Internal Server Error during deletion.' });
    } finally {
        client.release();
    }
};


/**
 * GET /api/files/:id/download
 * Initiates the download of a specific file.
 */
export const downloadFile = async (req, res) => {
    try {
        const itemId = req.params.id;
        const userId = req.user.id;

        // 1. Fetch file details and check ownership
        const result = await pool.query(
            `SELECT storage_key, name, mime_type, is_folder 
             FROM files 
             WHERE id = $1 AND user_id = $2`,
            [itemId, userId]
        );

        const file = result.rows[0];

        if (!file || file.is_folder) {
            return res.status(404).json({ message: 'File not found, is a folder, or access denied.' });
        }

        // 2. Construct the absolute file path
        const filePath = path.join(STORAGE_DIR, file.storage_key);

        // 3. Serve the file
        res.setHeader('Content-Type', file.mime_type);
        res.setHeader('Content-Disposition', `attachment; filename="${file.name}"`);
        // We use res.download as a robust method for serving files
        res.download(filePath, file.name, (err) => {
            if (err) {
                console.error('Error serving file:', err);
                if (!res.headersSent) {
                    res.status(500).json({ message: 'Could not serve file from storage.' });
                }
            }
        });

    } catch (error) {
        console.error('Error during file download:', error);
        res.status(500).json({ message: 'Internal Server Error during download.' });
    }
};
